#!/usr/bin/env stack
{- stack
    --install-ghc
    runghc
    --package turtle
    --package protolude
    --package unix
    --package xdg-basedir
-}

{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE OverloadedStrings #-}

import           Protolude                      hiding (FilePath, fold, (%),
                                                 (<>))
import           Turtle

import           Data.Text                      (words)
import           System.Environment.XDG.BaseDir (getUserDataDir)

import qualified Control.Foldl                  as L
import qualified Filesystem.Path.CurrentOS      as F
import qualified System.Posix.Files             as P

type PdfViewer = [Text]
type PID = Text

pdfViewer :: PdfViewer
pdfViewer = ["zathura", "evince", "okular"]

name :: Text
name = "Epdfphron"

version :: Text
version = "0.1.1"

banner :: Description
banner = fromString $ toS $
    name <> " v. " <> version <> " - the sheppard of your opened pdfs\n"
    <> "(C) 2017 Robin Raymond; licensed under GPL 3"

data CommandType
    = Status Bool
    | Save Text
    | Load Text
    | Show

data Command
    = Command
    { verbose :: Bool
    , action  :: CommandType
    }

cmdLine :: Parser Command
cmdLine = Command
        <$> (switch "verbose" 'v' "display verbose output")
        <*> (fmap Status
                (subcommand "status" "display information about current session"
                    (switch "computer" 'c' "display output parsable"))
           <|> fmap Save
                (subcommand "save" "save the current session to the database"
                    (optText "name" 'n' "name of session"))
           <|> fmap Load
                (subcommand "load" "restore a session from the database"
                    (optText "name" 'n' "name of session"))
           <|> (subcommand "show" "show saved sessions" (pure Show))
            )


viewerPattern :: [Text] -> Pattern Text
viewerPattern []     = mzero
viewerPattern (x:xs) = (text x) <|> viewerPattern xs

getProcDirs :: Shell PID
getProcDirs = do
    proc <- ls "/proc"
    s    <- liftIO $ stat proc
    let p = fmap toText $ stripPrefix "/proc/" proc

    case (p, isDirectory s) of
        (Just (Right q), True)
            -> if (not $ null (match decimal q))
                  then return q
                  else mzero
        otherwise -> mzero

isAccessible :: FilePath -> Shell Text
isAccessible p = do
    e <- testfile p

    let t = fmap toS $ toText p

    if e
    then do
        a <- liftIO $ mapM (\x -> P.fileAccess x True False True) t
        case (a, t) of
            (Right True, Right x) -> return (toS x)
            otherwise             -> mzero
    else mzero

getPIDs :: PdfViewer -> Shell PID
getPIDs viewers = do
    pd <- getProcDirs

    let exe = "/proc" </> (fromString $ toS pd) </> "exe"

    t <- isAccessible exe

    l <- liftIO $ P.readSymbolicLink (toS t)

    if (not $ null $ match (contains (viewerPattern viewers)) (toS l))
    then return pd
    else mzero


getOpenedFiles :: PID -> Shell FilePath
getOpenedFiles pid = do
    f <- ls ("/proc" </> (fromString $ toS pid) </> "fd")
    b <- testfile f
    if b
    then pure f
    else mzero


isPdf :: FilePath -> Bool
isPdf p = ((extension p) `elem` (fmap Just ["pdf", "djvu"]))

isTempFile :: Text -> Bool
isTempFile p = case stripPrefix "/tmp/" (fromText p) of
    Just _  -> True
    Nothing -> False

isRegFile :: MonadIO m => FilePath -> m Bool
isRegFile p = fmap isRegularFile (stat p)

main :: IO ()
main = do
    com <- options banner cmdLine
    let vb = verbose com
        ac = action com
    case ac of
        Status c -> status vb c
        _        -> echo "Stub. TODO: Implement"


getOpenedDocuments :: Bool -> Shell (PID, [Text])
getOpenedDocuments vb = do
    pid <- getPIDs pdfViewer
    when vb $ putStrLn (format ("Observing PID=" %s) pid)

    fd <- fold (getOpenedFiles pid) L.list

    when vb $ putStrLn ("Open Files:\n" :: Text) >> print fd

    real_path <- liftIO $ mapM (P.readSymbolicLink . F.encodeString) fd
    let paths = filter (isPdf . fromString) real_path

    when vb $ putStrLn ("Read Paths:\n" :: Text) >> print paths

    pure (pid, fmap toS paths)


printPath :: MonadIO m => Text -> m ()
printPath p = do
    putStr ("  * " :: Text)
    putStrLn p

status :: MonadIO m => Bool -> Bool -> m ()
status vb c = do
    dat <- fold (getOpenedDocuments vb) L.list
    let paths = fmap snd dat
        pids  = fmap fst dat
        rp = concat $ paths
        temp = filter isTempFile rp

    if c
    then mapM_ putStrLn rp
    else do
        putStrLn ("" :: Text)
        putStrLn $ format ("Found " %d% " running instance(s) of document viewers.")
                          (length pids)
        putStrLn ("" :: Text)
        putStrLn $ format ("The following " %d% " opened document(s) were found:")
                          (length rp)
        mapM_ printPath rp

        putStrLn ("" :: Text)
        putStrLn $ format ("The following " %d% " opened document(s) are temporary:")
                          (length temp)
        mapM_ printPath temp

        liftIO $ getUserDataDir "epdfphron" >>= print
